package com.proutechos.sandbox.radiolivealacarte.server.service;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.ObjectMapper;import com.proutechos.sandbox.radiolivealacarte.server.model.RadioStation;import java.io.IOException;import java.util.List;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.TimeUnit;public class RadioStreamingService {    // La fonction utilise l'API Radio Browser pour renvoyer tous les pays disponibles.    public String getAllCountries() throws Exception {        try {            // L'URL à laquelle faire l'appel            String url = "http://de1.api.radio-browser.info/json/countries";            // Créer un objet URL            URL obj = new URL(url);            // Ouvrir la connexion HTTP            HttpURLConnection con = (HttpURLConnection) obj.openConnection();            // Définir la méthode de requête comme GET            con.setRequestMethod("GET");            // Définir les propriétés de la requête            con.setRequestProperty("User-Agent", "Mozilla/5.0");            // Vérifier le code de réponse HTTP            int responseCode = con.getResponseCode();            System.out.println("Code de réponse HTTP : " + responseCode);            // Lire la réponse            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));            String inputLine;            StringBuffer response = new StringBuffer();            while ((inputLine = in.readLine()) != null) {                response.append(inputLine);            }            in.close();            // Afficher la réponse JSON            return ("Réponse JSON : " + response.toString());        } catch (Exception e) {            throw (e);        }    }    // Fonction qui met au format Camel Case une chaine de caractère.    private static String toCamelCase(String input) {        if (input == null || input.isEmpty()) {            return input;        }        // Diviser la chaîne en mots en utilisant les espaces, tirets et underscores comme séparateurs        String[] words = input.split("[\\s-_]+");        StringBuilder camelCaseString = new StringBuilder(words[0].toLowerCase());        for (int i = 1; i < words.length; i++) {            String word = words[i];            // Mettre en majuscule la première lettre de chaque mot à partir du second mot            camelCaseString.append(Character.toUpperCase(word.charAt(0)));            camelCaseString.append(word.substring(1).toLowerCase());        }        return camelCaseString.toString();    }    // La fonction utilise l'API Radio Browser pour renvoyer toutes les radios qui ont un nom similaire à celui recherché.    // La chaine de caractère passée en paramètre peut être composée de deux noms, l'espace sera enlevé par la suite.    public RadioStation[] searchByName(String name) throws Exception {        try {            // L'URL à laquelle faire l'appel            String camelCaseSearch = toCamelCase(name);            // Construction de l'URL en utilisant la variable camelCaseSearch            String url = "http://de1.api.radio-browser.info/json/stations/byname/" + camelCaseSearch;            // Créer un objet URL            URL obj = new URL(url);            // Ouvrir la connexion HTTP            HttpURLConnection con = (HttpURLConnection) obj.openConnection();            // Définir la méthode de requête comme GET            con.setRequestMethod("GET");            // Définir les propriétés de la requête            con.setRequestProperty("User-Agent", "Mozilla/5.0");            // Vérifier le code de réponse HTTP            int responseCode = con.getResponseCode();            // Lire la réponse            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));            String inputLine;            StringBuffer response = new StringBuffer();            while ((inputLine = in.readLine()) != null) {                response.append(inputLine);            }            in.close();            // Afficher la réponse JSON            String jsonString = response.toString();            ObjectMapper objectMapper = new ObjectMapper();            List<RadioStation> stations = objectMapper.readValue(jsonString, new TypeReference<List<RadioStation>>() {            });            // Afficher les objets RadioStation            for (RadioStation station : stations) {                System.out.println(station.toString());            }            return stations.toArray(new RadioStation[0]);        } catch (Exception e) {            throw (e);        }    }    public void programRecording() {        //LocalDateTime now = LocalDateTime.now();        //LocalDateTime targetTime = now.withHour(17).withMinute(54).withSecond(20);        // Si l'heure de 18:00 est déjà passée aujourd'hui, planifier pour demain        /*if (now.isAfter(targetTime)) {            targetTime = targetTime.plusDays(1);        }        // Calculer le délai en secondes jusqu'à 18:00        long delayInSeconds = Duration.between(now, targetTime).getSeconds();        System.out.println("Délai avant l'enregistrement : " + delayInSeconds + " secondes.");*/        // Utiliser ScheduledExecutorService pour retarder l'exécution        //ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();        //executorService.schedule(RadioStreamingService::recordRadio, 1, TimeUnit.SECONDS);        try {            TimeUnit.SECONDS.sleep(2);            recordRadio();        } catch (InterruptedException ie) {            Thread.currentThread().interrupt();        }    }    public static void recordRadio() {        // Définir la commande à exécuter        String[] command = {                "ffmpeg",                "-i", "https://stream.radiofrance.fr/franceinfo/franceinfo_hifi.m3u8?id=radiofrance",                "-t", "00:00:05",                "-c:v", "copy",                "-c:a", "libmp3lame",                "src/main/resources/static/mp3/sortie2092024.mp3"        };        // Créer un ProcessBuilder avec la commande        ProcessBuilder processBuilder = new ProcessBuilder(command);        try {            // Démarrer le processus            Process process = processBuilder.start();            // Lire la sortie du processus            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));            String line;            while ((line = reader.readLine()) != null) {                System.out.println(line);            }            // Lire les erreurs du processus            BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));            while ((line = errorReader.readLine()) != null) {                System.err.println(line);            }            // Attendre que le processus se termine            int exitCode = process.waitFor();            System.out.println("Process exited with code: " + exitCode);        } catch (IOException | InterruptedException e) {            e.printStackTrace();        }    }    private static RadioStreamingService _instance = new RadioStreamingService();    public static RadioStreamingService getInstance() {        return _instance;    }}