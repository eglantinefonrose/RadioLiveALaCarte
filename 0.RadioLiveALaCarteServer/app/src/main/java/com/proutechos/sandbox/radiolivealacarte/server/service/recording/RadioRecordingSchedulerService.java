package com.proutechos.sandbox.radiolivealacarte.server.service.recording;import org.quartz.*;import org.quartz.impl.StdSchedulerFactory;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.text.SimpleDateFormat;import java.util.Date;import java.util.UUID;import static org.quartz.JobBuilder.newJob;import static org.quartz.TriggerBuilder.newTrigger;import java.io.*;import java.nio.file.*;import java.util.ArrayList;import java.util.List;public class RadioRecordingSchedulerService {    /**     *     * @throws SchedulerException     */    public void programRecording(int startHour, int startMinute, int startSeconds, int endHour, int endMinute, int endSeconds, int withSegments, String url) throws SchedulerException {        // Créer une instance du scheduler        Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();        // Démarrer le scheduler        scheduler.start();        // Définir les données à passer au job (les heures et minutes dynamiques)        JobDataMap jobDataMap = new JobDataMap();        jobDataMap.put("startHour", startHour);        jobDataMap.put("startMinute", startMinute);        jobDataMap.put("startSeconds", startSeconds);        jobDataMap.put("endHour", endHour);        jobDataMap.put("endMinute", endMinute);        jobDataMap.put("endSeconds", endSeconds);        jobDataMap.put("withSegments", withSegments);        jobDataMap.put("url", url);        // Définir le job pour démarrer la tâche        JobDetail startJob = newJob(RadioJob.class)                .withIdentity("radioJobStart", "group-" + UUID.randomUUID().toString())  // Nommer le job de démarrage                .usingJobData(jobDataMap)                .build();        // Définir un autre job pour arrêter la tâche        JobDetail stopJob = newJob(StopRadioJob.class)                .withIdentity("radioJobStop", "group-" + UUID.randomUUID().toString())  // Nommer le job d'arrêt                .usingJobData(jobDataMap)  // Vous pouvez transmettre les mêmes données ou des données spécifiques pour l'arrêt                .build();        // Créer un déclencheur pour exécuter le job à l'heure de début spécifique        Trigger startTrigger = newTrigger()                .withIdentity("radioStartTrigger", "group-" + UUID.randomUUID().toString())  // Nommer le déclencheur                .withSchedule(CronScheduleBuilder.dailyAtHourAndMinute(startHour, startMinute))  // Planifier à l'heure de début                .forJob(startJob)                .build();        // Créer un déclencheur pour arrêter le job à l'heure de fin spécifique        Trigger stopTrigger = newTrigger()                .withIdentity("radioStopTrigger", "group-" + UUID.randomUUID().toString())  // Nommer le déclencheur                .withSchedule(CronScheduleBuilder.dailyAtHourAndMinute(endHour, endMinute))  // Planifier à l'heure de fin                .forJob(stopJob)                .build();        // Ajouter le job de démarrage et son déclencheur au scheduler        scheduler.scheduleJob(startJob, startTrigger);        // Ajouter le job d'arrêt et son déclencheur au scheduler        scheduler.scheduleJob(stopJob, stopTrigger);    }    /**     *     */    public static void recordRadio(int startHour, int startMinute, int startSeconds, int endHour, int endMinute, int endSeconds, String url) {        String tempsEnregistrement = calculerDifferenceHeure(startHour, startMinute, startSeconds, endHour, endMinute, endSeconds);        String[] command = {                "ffmpeg",                "-i", "https://stream.radiofrance.fr/franceinfo/franceinfo_hifi.m3u8?id=radiofrance",                "-t", tempsEnregistrement,                "-c:v", "copy",                "-c:a", "libmp3lame",                "./src/main/resources/static/media/mp3/sortie1429.mp3"        };        ProcessBuilder processBuilder = new ProcessBuilder(command);        try {            Process process = processBuilder.start();            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));            String line;            while ((line = reader.readLine()) != null) {                System.out.println(line);            }            BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));            while ((line = errorReader.readLine()) != null) {                System.err.println(line);            }            int exitCode = process.waitFor();            System.out.println("Process exited with code: " + exitCode);        } catch (IOException | InterruptedException e) {            e.printStackTrace();        }    }    private static String calculerDifferenceHeure(int heureDebut, int minuteDebut, int secondeDebut, int heureFin, int minuteFin, int secondeFin) {        // Convertir le début et la fin en secondes        int debutEnSecondes = heureDebut * 3600 + minuteDebut * 60 + secondeDebut;        int finEnSecondes = heureFin * 3600 + minuteFin * 60 + secondeFin;        // Calculer la différence en secondes        int differenceEnSecondes = finEnSecondes - debutEnSecondes;        // Gérer le cas où la différence est négative (si l'heure de fin est après minuit)        if (differenceEnSecondes < 0) {            differenceEnSecondes += 24 * 3600;  // Ajouter 24 heures en secondes        }        // Convertir la différence en heures, minutes et secondes        int heures = differenceEnSecondes / 3600;        differenceEnSecondes %= 3600;        int minutes = differenceEnSecondes / 60;        int secondes = differenceEnSecondes % 60;        // Retourner la chaîne de caractères formatée        return String.format("%02d:%02d:%02d", heures, minutes, secondes);    }    //    //    // IMPLEMENTATION    //    //    //    //    // SINGLETON    //    //    private static RadioRecordingSchedulerService _instance = new RadioRecordingSchedulerService();    public static RadioRecordingSchedulerService getInstance() {        return _instance;    }}