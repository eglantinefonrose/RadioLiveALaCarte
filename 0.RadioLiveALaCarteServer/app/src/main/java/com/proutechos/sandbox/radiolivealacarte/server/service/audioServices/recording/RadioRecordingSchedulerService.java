package com.proutechos.sandbox.radiolivealacarte.server.service.audioServices.recording;import com.proutechos.sandbox.radiolivealacarte.server.model.Program;import com.proutechos.sandbox.radiolivealacarte.server.model.RadioStation;import com.proutechos.sandbox.radiolivealacarte.server.service.dataServices.dataStorage.RadioLiveALaCarteDataStorage;import com.proutechos.sandbox.radiolivealacarte.server.service.audioServices.planning.RadioInformationAndPlanningService;import com.proutechos.utils.server.rest.config.exceptions.ProutechosBaseException;import org.quartz.*;import org.quartz.impl.StdSchedulerFactory;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.UUID;import static org.quartz.JobBuilder.newJob;import static org.quartz.TriggerBuilder.newTrigger;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.time.Instant;import java.time.LocalTime;import java.time.ZoneId;import java.time.format.DateTimeFormatter;public class RadioRecordingSchedulerService {    /**     *     * @throws SchedulerException     */    public String recordFromHourly(String uuid, int startTime, int endTime, int withSegments, String url, Integer danielMorinVersion) throws ProutechosBaseException {        try {            // Créer une instance du scheduler            Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();            // Démarrer le scheduler            scheduler.start();            Boolean withSegmentsBool;            if (withSegments == 1) {                withSegmentsBool = Boolean.TRUE;            } else {                withSegmentsBool = Boolean.FALSE;            }            String outputFileName = "";            outputFileName = "output_" + uuid + "_" + startTime;            // Définir les données à passer au job (les heures et minutes dynamiques)            JobDataMap jobDataMap = new JobDataMap();            jobDataMap.put("startTime", startTime);            jobDataMap.put("endTime", endTime);            jobDataMap.put("withSegments", withSegments);            jobDataMap.put("outputFileName", outputFileName);            jobDataMap.put("danielMorinVersion", danielMorinVersion);            jobDataMap.put("url", url);            // Définir le job pour démarrer la tâche            JobDetail startJob = newJob(RadioJob.class)                    .withIdentity("radioJobStart", "group-" + UUID.randomUUID().toString())  // Nommer le job de démarrage                    .usingJobData(jobDataMap)                    .build();            // Définir un autre job pour arrêter la tâche            JobDetail stopJob = newJob(StopRadioJob.class)                    .withIdentity("radioJobStop", "group-" + UUID.randomUUID().toString())  // Nommer le job d'arrêt                    .usingJobData(jobDataMap)  // Vous pouvez transmettre les mêmes données ou des données spécifiques pour l'arrêt                    .build();            // Créer un déclencheur pour exécuter le job à l'heure de début spécifique            Date triggerTime = new Date(startTime);            // Créer le trigger basé sur le temps Epoch            Trigger startTrigger = newTrigger()                    .withIdentity("radioStartTrigger", "group-" + UUID.randomUUID().toString())                    .startAt(triggerTime)                    .forJob(startJob)                    .build();            // Créer un déclencheur pour arrêter le job à l'heure de fin spécifique            Date triggerEnd = new Date(endTime);            // Créer le trigger basé sur le temps Epoch            Trigger stopTrigger = newTrigger()                    .withIdentity("radioStopTrigger", "group-" + UUID.randomUUID().toString())                    .startAt(triggerEnd)                    .forJob(stopJob)                    .build();            // Ajouter le job de démarrage et son déclencheur au scheduler            scheduler.scheduleJob(startJob, startTrigger);            // Ajouter le job d'arrêt et son déclencheur au scheduler            scheduler.scheduleJob(stopJob, stopTrigger);            return outputFileName;        } catch (SchedulerException e) {            throw new ProutechosBaseException(e.toString());        }    }    public void recordProgram(Program program, Integer danielMorinVersion) throws ProutechosBaseException {        try {            String wellFormattedRadioName = program.getRadioName().replace("%20", " ");            System.out.println(wellFormattedRadioName);            RadioStation[] radioStations = RadioInformationAndPlanningService.getInstance().searchByName(wellFormattedRadioName);            String url = radioStations[0].getUrl_resolved();            int startTime = program.getStartTime();            int endTime = program.getEndTime();            String uuid = String.valueOf(UUID.randomUUID());            String fileWithoutSegmentsName = recordFromHourly(uuid, startTime, endTime, 0, url, danielMorinVersion);            String baseFileSegmentedName = recordFromHourly(uuid, startTime, endTime, 1, url, danielMorinVersion);            RadioLiveALaCarteDataStorage.getInstance().addProgramFileNames(program,fileWithoutSegmentsName, baseFileSegmentedName);        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public static String getNextScheduledTime(String time) {        try {            // Définition du format de sortie            SimpleDateFormat dateFormat = new SimpleDateFormat("MM/dd/yy HH:mm:ss");            SimpleDateFormat fullFormat = new SimpleDateFormat("MM/dd/yy HH:mm:ss");            SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm:ss");            // Récupération de la date actuelle            Calendar now = Calendar.getInstance();            Calendar scheduledTime = Calendar.getInstance();            // Définition de l'heure prévue en gardant la date du jour            Date parsedTime = timeFormat.parse(time);            scheduledTime.set(Calendar.HOUR_OF_DAY, parsedTime.getHours());            scheduledTime.set(Calendar.MINUTE, parsedTime.getMinutes());            scheduledTime.set(Calendar.SECOND, parsedTime.getSeconds());            // Vérifier si l'heure est déjà passée aujourd'hui            if (scheduledTime.before(now)) {                scheduledTime.add(Calendar.DAY_OF_MONTH, 1); // Passer au lendemain            }            // Retourner la date formatée            return dateFormat.format(scheduledTime.getTime());        } catch (Exception e) {            e.printStackTrace();            return null;        }    }    public static void scheduleWake(long timeEpoch) throws IOException {        LocalTime time = Instant.ofEpochSecond(timeEpoch)                .atZone(ZoneId.systemDefault()) // Ou un autre fuseau comme ZoneId.of("Europe/Paris")                .toLocalTime();        // Formatage en hh:mm:ss        String formattedTime = time.format(DateTimeFormatter.ofPattern("HH:mm:ss"));        // Commande `pmset` pour programmer le réveil        String command = "sudo pmset schedule wakeorpoweron \"" + getNextScheduledTime(formattedTime) + "\"";        // Exécution de la commande        Process process = Runtime.getRuntime().exec(new String[]{"/bin/bash", "-c", command});        try {            process.waitFor(); // Attendre l'exécution de la commande        } catch (InterruptedException e) {            e.printStackTrace();        }    }    /**     *     */    public static void recordRadio(int startHour, int startMinute, int startSeconds, int endHour, int endMinute, int endSeconds, String url) {        String tempsEnregistrement = calculerDifferenceHeure(startHour, startMinute, startSeconds, endHour, endMinute, endSeconds);        String[] command = {                "ffmpeg",                "-i", "https://stream.radiofrance.fr/franceinfo/franceinfo_hifi.m3u8?id=radiofrance",                "-t", tempsEnregistrement,                "-c:v", "copy",                "-c:a", "libmp3lame",                "./src/main/resources/static/media/mp3/sortie1429.mp3"        };        ProcessBuilder processBuilder = new ProcessBuilder(command);        try {            Process process = processBuilder.start();            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));            String line;            while ((line = reader.readLine()) != null) {                System.out.println(line);            }            BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));            while ((line = errorReader.readLine()) != null) {                System.err.println(line);            }            int exitCode = process.waitFor();            System.out.println("Process exited with code: " + exitCode);        } catch (IOException | InterruptedException e) {            e.printStackTrace();        }    }    private static String calculerDifferenceHeure(int heureDebut, int minuteDebut, int secondeDebut, int heureFin, int minuteFin, int secondeFin) {        // Convertir le début et la fin en secondes        int debutEnSecondes = heureDebut * 3600 + minuteDebut * 60 + secondeDebut;        int finEnSecondes = heureFin * 3600 + minuteFin * 60 + secondeFin;        // Calculer la différence en secondes        int differenceEnSecondes = finEnSecondes - debutEnSecondes;        // Gérer le cas où la différence est négative (si l'heure de fin est après minuit)        if (differenceEnSecondes < 0) {            differenceEnSecondes += 24 * 3600;  // Ajouter 24 heures en secondes        }        // Convertir la différence en heures, minutes et secondes        int heures = differenceEnSecondes / 3600;        differenceEnSecondes %= 3600;        int minutes = differenceEnSecondes / 60;        int secondes = differenceEnSecondes % 60;        // Retourner la chaîne de caractères formatée        return String.format("%02d:%02d:%02d", heures, minutes, secondes);    }    //    //    // IMPLEMENTATION    //    //    //    //    // SINGLETON    //    //    private static RadioRecordingSchedulerService _instance = new RadioRecordingSchedulerService();    public static RadioRecordingSchedulerService getInstance() {        return _instance;    }}